/*
 * test.c
 *
 *  Created on: Apr 16, 2023
 *      Author: anil
 */

struct queueNode
{
	double data;
	struct buf_handle_t *next;
};

struct queueNode *headPtr;
struct queueNode *tailPtr;

void	enqueue(struct queueNode **headNode, struct queueNode **headPtr, struct queueNode **tailPtr, double data)
{
	struct queueNode *newNode = (struct queueNode*)malloc(sizeof(struct queueNode));
	if (newNode)
	{
		newNode->data = data;
		newNode->next = NULL;

		if (!(*headPtr))
			*headPtr = newNode;
		else
			(*tailPtr) -> next = newNode;
		*tailPtr = newNode;
	}
	newNode -> next = *headNode;
	*headNode = newNode;
}

void	dequeue(struct queueNode **headNode)
{
	struct queueNode *temp = *headNode;
	*headNode = *headNode -> next;

}

void 	swap(double *n1, double *n2)
{
	double swap = *n1;
	*n1 = *n2;
	*n2 = swap;
}

void	sort_array(double *raw_sensor_value, size_t size)
{
	for (int i = 0; i < size - 1; ++i) {
		for (int j = i + 1; j < size; ++j) {
			if (arr[i] > arr[j])
				swap(&arr[i], &arr[j]);
		}
	}
}

double *filter_sensor_value(double *raw_sensor_value, size_t size, uint8_t window_size)
{
	sort_array(raw_sensor_value, size);
	int median_idx;
	double *filtered_arr = (double*)malloc(sizeof(double) * (size - window_size + 1));
	for (int var = 0; var < size; ++var) {
		median_idx = (var + window_size) / 2;
		if (window_size % 2)
			filtered_arr[var] = raw_sensor_value[median_idx];
		else // if window size is even
			filtered_arr[var] = (raw_sensor_value[median_idx] + raw_sensor_value[median_idx + 1]) / 2.0;
	}
	return filtered_arr;
}
