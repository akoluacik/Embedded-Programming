/*
 * BME_280.c
 *
 *  Created on: Apr 16, 2023
 *      Author: anil
 */


#define SUPPORT_64BIT 1

#include "BME_280.h"
#include <stddef.h>
extern I2C_HandleTypeDef hi2c1;



uint16_t dig_T1,  \
         dig_P1, \
         dig_H1, dig_H3;

int16_t  dig_T2, dig_T3, \
         dig_P2, dig_P3, dig_P4, dig_P5, dig_P6, dig_P7, dig_P8, dig_P9, \
		 dig_H2,  dig_H4, dig_H5, dig_H6;

int32_t raw_p, raw_t, raw_h;
float temperature;
float humidity;
float pressure;


BME_280_Response	BME_280_softReset(void)
{
	HAL_StatusTypeDef res = HAL_I2C_Mem_Write(&hi2c1, DEVICE_ADD, RESET, 1, (uint8_t*)SOFT_RESET, 1, 100);
	HAL_Delay(100);
	if (res != HAL_OK)
		return BME_280_ERROR;
	return BME_280_OK;
}

void	BME_280_trimmingParameter(void)
{
	HAL_StatusTypeDef ret;
	uint8_t reg_val[32];
	uint
	ret = HAL_I2C_Mem_Read(&hi2c1, DEVICE_ADD | 0x01, 0x88, 25, reg_val, 25, 100);
	if (ret != HAL_OK)
		return BME_280_ERROR;
	dig_T1 = ((reg_val[1] << 8) | reg_val[0]);
	dig_T2 = ((reg_val[3] << 8) | reg_val[2]);
	dig_T3 = ((reg_val[5] << 8) | reg_val[4]);
	dig_P1 = ((reg_val[7] << 8) | reg_val[6]);
	dig_P2 = ((reg_val[9] << 8) | reg_val[8]);
	dig_P3 = ((reg_val[11] << 8) | reg_val[10]);
	dig_P4 = ((reg_val[13] << 8) | reg_val[12]);
	dig_P5 = ((reg_val[15] << 8) | reg_val[14]);
	dig_P6 = ((reg_val[17] << 8) | reg_val[16]);
	dig_P7 = ((reg_val[19] << 8) | reg_val[18]);
	dig_P8 = ((reg_val[21] << 8) | reg_val[20]);
	dig_P9 = ((reg_val[23] << 8) | reg_val[22]);
	dig_H1 = (reg_val[24]);
	dig_H2 = ((reg_val[26] << 8) | reg_val[25]);
	dig_H3 = (reg_val[27]);
	dig_H4 = ((reg_val[28] << 4) | reg_val[29] & 0x0F);
	dig_H5 = ((reg_val[30] << 4) | reg_val[29] >> 4);
	dig_H6 = (reg_val[31]);

}

BME_280_Response	BME_280_config(uint8_t osrs_t, uint8_t osrs_p, uint8_t osrs_h, uint8_t mode, uint8_t t_sb, uint8_t filter)
{
	BME_280_Response ret;
	HAL_StatusTypeDef res;

	// Soft Reset
	ret = BME_280_softReset();
	if (ret != BME_280_OK)
		return BME_280_ERROR;
	BME_280_trimmingParameter();
	// Humidity data acquistion options
	res = HAL_I2C_Mem_Write(&hi2c1, DEVICE_ADD, CTRL_HUM, 1, (uint8_t*)osrs_h, 1, 100);
	HAL_Delay(100);
	if (res != HAL_OK)
		return BME_280_ERROR;

	// Configurations of Humidity
	res= HAL_I2C_Mem_Write(&hi2c1, DEVICE_ADD, CONFIG, 1, (uint8_t*)((t_sb << 5) | (filter << 2)), 1, 100);
	HAL_Delay(100);
	if (res != HAL_OK)
			return BME_280_ERROR;

	// Temperature and Pressure data acquistion options
	res = HAL_I2C_Mem_Write(&hi2c1, DEVICE_ADD, CTRL_MEAS, 1, (uint8_t*)(osrs_t << 5 | osrs_p << 2 | mode), 1, 100);
	HAL_Delay(100);
	if (res != HAL_OK)
		return BME_280_ERROR;

	// Temperature and Pressure Configuration
	res= HAL_I2C_Mem_Write(&hi2c1, DEVICE_ADD, CONFIG, 1, (uint8_t*)((t_sb << 5) | (filter << 2)), 1, 100);
	HAL_Delay(100);
	if (res != HAL_OK)
			return BME_280_ERROR;
	return BME_280_OK;
}


/* Returns temperature in DegC, resolution is 0.01 DegC. Output value of “5123” equals 51.23 DegC.
   t_fine carries fine temperature as global value
*/
int32_t t_fine;
int32_t BME280_compensate_T_int32(int32_t adc_T)
{
	int32_t var1, var2, T;
	var1 = ((((adc_T>>3) - ((int32_t)dig_T1<<1))) * ((int32_t)dig_T2)) >> 11;
	var2 = (((((adc_T>>4) - ((int32_t)dig_T1)) * ((adc_T>>4) - ((int32_t)dig_T1)))>> 12) *((int32_t)dig_T3)) >> 14;
	t_fine = var1 + var2;
	T = (t_fine * 5 + 128) >> 8;
	return T;
}


#if SUPPORT_64BIT
/* Returns pressure in Pa as unsigned 32 bit integer in Q24.8 format (24 integer bits and 8 fractional bits).
   Output value of “24674867” represents 24674867/256 = 96386.2 Pa = 963.862 hPa
*/
uint32_t BME280_compensate_P_int64(int32_t adc_P)
{
	int64_t var1, var2, p;
	var1 = ((int64_t)t_fine) - 128000;
	var2 = var1 * var1 * (int64_t)dig_P6;
	var2 = var2 + ((var1*(int64_t)dig_P5)<<17);
	var2 = var2 + (((int64_t)dig_P4)<<35);
	var1 = ((var1 * var1 * (int64_t)dig_P3)>>8) + ((var1 * (int64_t)dig_P2)<<12);
	var1 = (((((int64_t)1)<<47)+var1))*((int64_t)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0; // avoid exception caused by division by zero
	}
	p = 1048576-adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((int64_t)dig_P9) * (p>>13) * (p>>13)) >> 25;
	var2 = (((int64_t)dig_P8) * p) >> 19;
	p = ((p + var1 + var2) >> 8) + (((int64_t)dig_P7)<<4);
	return (uint32_t)p;
}

#elif SUPPORT_32BIT
// Returns pressure in Pa as unsigned 32 bit integer. Output value of “96386” equals 96386 Pa = 963.86 hPa
uint32_t BME280_compensate_P_int32(int32_t adc_P)
{
	int32_t var1, var2;
	uint32_t p;
	var1 = (((int32_t)t_fine)>>1) - (int32_t)64000;
	var2 = (((var1>>2) * (var1>>2)) >> 11 ) * ((int32_t)dig_P6);
	var2 = var2 + ((var1*((int32_t)dig_P5))<<1);
	var2 = (var2>>2)+(((int32_t)dig_P4)<<16);
	var1 = (((dig_P3 * (((var1>>2) * (var1>>2)) >> 13 )) >> 3) + ((((int32_t)dig_P2) *var1)>>1))>>18;
	var1 =((((32768+var1))*((int32_t)dig_P1))>>15);
	if (var1 == 0)
	{
		return 0; // avoid exception caused by division by zero
	}
	p = (((uint32_t)(((int32_t)1048576)-adc_P)-(var2>>12)))*3125;
	if (p < 0x80000000)
	{
		p = (p << 1) / ((uint32_t)var1);
	}
	else
	{
		p = (p / (uint32_t)var1) * 2;
	}
	var1 = (((int32_t)dig_P9) * ((int32_t)(((p>>3) * (p>>3))>>13)))>>12;
	var2 = (((int32_t)(p>>2)) * ((int32_t)dig_P8))>>13;
	p = (uint32_t)((int32_t)p + ((var1 + var2 + dig_P7) >> 4));
	return p;
}
#endif

/* Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
   Output value of “47445” represents 47445/1024 = 46.333 %RH
*/
uint32_t bme280_compensate_H_int32(int32_t adc_H)
{
	int32_t v_x1_u32r;
	v_x1_u32r = (t_fine - ((int32_t)76800));
	v_x1_u32r = (((((adc_H << 14) - (((int32_t)dig_H4) << 20) - (((int32_t)dig_H5) *\
			v_x1_u32r)) + ((int32_t)16384)) >> 15) * (((((((v_x1_u32r *\
					((int32_t)dig_H6)) >> 10) * (((v_x1_u32r * ((int32_t)dig_H3)) >> 11) +\
							((int32_t)32768))) >> 10) + ((int32_t)2097152)) * ((int32_t)dig_H2) +\
					8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *\
			((int32_t)dig_H1)) >> 4));
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
	return (uint32_t)(v_x1_u32r>>12);
}

BME_280_Response	BME_280_measure(void)
{
	HAL_StatusTypeDef res;
	uint8_t raw_data[8];

	res = HAL_I2C_Mem_Read(&hi2c1, DEVICE_ADD, (uint16_t)PRESS_MSB_REG, 1, raw_data, 8, 100);
	if (res != HAL_OK)
		return BME_280_ERROR;
	raw_p = (raw_data[0] << 12) | (raw_data[1] << 4) | (raw_data[2] >> 4);
	raw_t = (raw_data[3] << 12) | (raw_data[4] << 4) | (raw_data[5] >> 4);
	raw_h = (raw_data[0] << 8) | (raw_data[1]);

	if (tRaw == 0x800000)
		Temperature = 0; // value in case temp measurement was disabled
	else
		temperature = (BME280_compensate_T_int32 (tRaw))/100.0;  // as per datasheet, the temp is x100
	if (pRaw == 0x800000) Pressure = 0; // value in case temp measurement was disabled
	else
	{
		#if SUPPORT_64BIT
			pressure = (BME280_compensate_P_int64 (pRaw))/256.0;  // as per datasheet, the pressure is x256

		#elif SUPPORT_32BIT
			pressure = (BME280_compensate_P_int32 (pRaw));  // as per datasheet, the pressure is Pa

		#endif
	}
	if (hRaw == 0x8000)
		humidity = 0; // value in case temp measurement was disabled
	else
		humidity = (bme280_compensate_H_int32 (hRaw))/1024.0;  // as per datasheet, the temp is x1024

	return BME_280_OK;
}
